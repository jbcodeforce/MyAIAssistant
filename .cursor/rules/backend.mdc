---
alwaysApply: false
description: Backend API context - FastAPI, SQLAlchemy async, ChromaDB RAG, and LLM integration
globs:
  - backend/**
---

# MyAIAssistant Backend

A FastAPI backend providing REST APIs for task management, knowledge base operations, RAG-based semantic search, and LLM-powered chat with agent routing.

## Technology Stack

| Component | Technology | Version |
|-----------|------------|---------|
| Web Framework | FastAPI | >=0.115.0 |
| Python | Python | >=3.12 |
| ORM | SQLAlchemy | >=2.0.0 (async) |
| Database | PostgreSQL | via asyncpg |
| Validation | Pydantic | >=2.0.0 |
| LLM/RAG | agent-core | local package |
| HTTP Client | httpx | >=0.27.0 |
| Package Manager | uv | - |
| Testing | pytest + pytest-asyncio | >=8.0.0 |

## Project Structure

```
backend/
├── app/
│   ├── main.py              # FastAPI app factory, lifespan, CORS
│   ├── config.yaml          # Default configuration
│   ├── api/                  # Route handlers
│   │   ├── todos.py         # Todo CRUD endpoints
│   │   ├── knowledge.py     # Knowledge item endpoints
│   │   ├── rag.py           # Indexing and search endpoints
│   │   ├── chat.py          # LLM chat endpoints
│   │   ├── organizations.py # Organization endpoints
│   │   ├── projects.py      # Project endpoints
│   │   ├── metrics.py       # Metrics endpoints
│   │   ├── settings.py      # Settings endpoints
│   │   └── schemas/         # Pydantic request/response models
│   │       ├── todo.py
│   │       ├── knowledge.py
│   │       ├── rag.py
│   │       ├── chat.py
│   │       └── ...
│   ├── core/
│   │   └── config.py        # Settings singleton, YAML config loading
│   ├── db/
│   │   ├── database.py      # Async engine, session maker
│   │   ├── models.py        # SQLAlchemy ORM models
│   │   └── crud/            # Database operations by entity
│   │       ├── todo.py
│   │       ├── knowledge.py
│   │       └── ...
│   └── chat/
│       └── service.py       # Chat service using agent_core
├── tests/
│   ├── conftest.py          # Test fixtures, DB/RAG overrides
│   └── ut/                   # Unit tests
└── pyproject.toml
```

## Integration with agent_core

The backend uses the `agent_core` library for LLM integration. RAG service, and agent routing:

```python
# LLM Client
from agent_core import LLMClient, LLMConfig, Message as LLMMessage

config = LLMConfig(
    provider=settings.llm_provider,
    model=settings.llm_model,
    api_key=settings.llm_api_key,
    base_url=settings.llm_base_url
)
client = LLMClient(config)

# RAG Service
from agent_core.services.rag.service import RAGService, get_rag_service

rag = get_rag_service()
results = await rag.search(query, n_results=5)

# Agent Routing
from agent_core.agents.agent_router import AgentRouter, get_agent_router

router = get_agent_router()
response = await router.route(query, conversation_history)
```

## Core Patterns

### Async Database with SQLAlchemy 2.0

```python
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.database import get_db

@router.get("/items/{id}")
async def get_item(id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Model).where(Model.id == id))
    return result.scalar_one_or_none()
```

- Use `AsyncSession` for all database operations
- Use `select()` statements with `await db.execute()`
- Models inherit from `Base` with `AsyncAttrs, DeclarativeBase`
- Use `Mapped[type]` and `mapped_column()` for type-safe columns

### Pydantic Schemas

```python
from pydantic import BaseModel, Field, ConfigDict

class ItemCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=255)
    description: str | None = None

class ItemResponse(ItemCreate):
    id: int
    created_at: datetime
    model_config = ConfigDict(from_attributes=True)
```

- Separate schemas for Create, Update, and Response
- Use `Field()` for validation constraints
- Set `from_attributes=True` for ORM model conversion
- Use `Optional[type]` or `type | None` for nullable fields

### Dependency Injection

```python
from fastapi import Depends

def get_service() -> Service:
    return get_singleton_service()

@router.post("/action")
async def action(
    db: AsyncSession = Depends(get_db),
    service: Service = Depends(get_service)
):
    ...
```

### Configuration

Configuration loads from multiple sources (highest priority first):
1. Environment variables
2. `.env` file
3. `CONFIG_FILE` yaml (user overrides)
4. Default `app/config.yaml`

Access settings via singleton:
```python
from app.core.config import get_settings
settings = get_settings()
```

### Chat Service with Agent Routing

```python
from app.chat.service import get_chat_service

chat = get_chat_service()

# Direct chat (no routing)
response = await chat.chat_with_rag(user_message, history)

# With agent routing (intelligent query handling)
response = await chat.route_query(user_message, history)
print(response.intent)      # QueryIntent value
print(response.agent_type)  # Which agent handled it
```

## API Conventions

| Method | Path Pattern | Purpose |
|--------|--------------|---------|
| GET | `/api/{resource}` | List with pagination |
| GET | `/api/{resource}/{id}` | Get single item |
| POST | `/api/{resource}` | Create item |
| PUT | `/api/{resource}/{id}` | Update item |
| DELETE | `/api/{resource}/{id}` | Delete item |

- All routes prefixed with `/api`
- Use `Query()` for optional filters
- Return 404 for missing resources
- Use status code 201 for creates, 204 for deletes

## Testing

Tests use pytest-asyncio with in-memory SQLite and isolated ChromaDB:

```python
@pytest.fixture
async def client(db_session):
    app.dependency_overrides[get_db] = override_get_db
    async with AsyncClient(...) as ac:
        yield ac
```

Run tests:
```bash
uv run pytest
uv run pytest tests/ut/test_todos.py -v
```

## Development Commands

```bash
# Install dependencies
uv sync

# Run dev server
uv run uvicorn app.main:app --reload

# Run with custom config
CONFIG_FILE=/path/to/config.yaml uv run uvicorn app.main:app --reload

# Run tests
uv run pytest

# Check config
curl http://localhost:8000/debug/config
```

## Best Practices

1. **Always use async/await** for database and HTTP operations
2. **Validate with Pydantic** - never trust raw input
3. **Use dependency injection** for services and DB sessions
4. **Handle errors explicitly** - raise HTTPException with appropriate status codes
5. **Write tests first** - follow TDD pattern per `tdd.mdc` rule
6. **Keep routes thin** - business logic in services, not route handlers
7. **Use type hints everywhere** - enables IDE support and validation
8. **Log important operations** - use the logging module, not print
9. **Use agent_core** - prefer agent_core types and services over duplicating logic
